<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K√§stchen-Z√§hler (OpenCV)</title>
  <style>
    body{font-family:system-ui; padding:16px; max-width:760px; margin:auto;}
    button{padding:10px 14px; font-size:16px;}
    #out{white-space:pre-wrap; background:#f4f4f4; padding:12px; border-radius:10px;}
    canvas{max-width:100%; border-radius:10px; margin-top:10px; display:none;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .small{font-size:12px; opacity:.75;}
  </style>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
  <h2>K√§stchen-Z√§hler (Foto ‚Üí Rot/Gr√ºn z√§hlen)</h2>

  <div class="row">
    <input id="photo" type="file" accept="image/*" capture="environment" />
    <button id="run" disabled>Auswerten</button>
  </div>

  <p class="small" id="status">OpenCV l√§dt‚Ä¶</p>
  <pre id="out">Foto w√§hlen ‚Üí Auswerten</pre>
  <canvas id="cv"></canvas>

<script>
const out = document.getElementById("out");
const statusEl = document.getElementById("status");
const runBtn = document.getElementById("run");
const fileInput = document.getElementById("photo");
const canvas = document.getElementById("cv");
const ctx = canvas.getContext("2d", { willReadFrequently: true });

function loadImageFromFile(file){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error("Bild konnte nicht geladen werden (onerror)."));
    img.src = URL.createObjectURL(file);
  });
}

function morphClean(bin) {
  const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
  const tmp = new cv.Mat();
  const outm = new cv.Mat();
  cv.morphologyEx(bin, tmp, cv.MORPH_OPEN, kernel, new cv.Point(-1,-1), 1);
  cv.morphologyEx(tmp, outm, cv.MORPH_CLOSE, kernel, new cv.Point(-1,-1), 2);
  tmp.delete(); kernel.delete();
  return outm;
}

function countSquares(mask) {
  const labels = new cv.Mat();
  const stats  = new cv.Mat();
  const cent   = new cv.Mat();
  const n = cv.connectedComponentsWithStats(mask, labels, stats, cent, 8, cv.CV_32S);

  let count = 0;
  for (let i = 1; i < n; i++) {
    const w = stats.intAt(i, cv.CC_STAT_WIDTH);
    const h = stats.intAt(i, cv.CC_STAT_HEIGHT);
    const area = stats.intAt(i, cv.CC_STAT_AREA);

    // etwas toleranter (weil Downsizing/Handy)
    if (area < 120 || area > 20000) continue;

    const aspect = w / h;
    if (aspect < 0.65 || aspect > 1.55) continue;

    const fill = area / (w * h);
    if (fill < 0.30) continue;

    count++;
  }

  labels.delete(); stats.delete(); cent.delete();
  return count;
}

async function run(){
  try {
    const f = fileInput.files[0];
    if (!f) { out.textContent = "Bitte zuerst ein Foto ausw√§hlen."; return; }

    out.textContent = "Analysiere‚Ä¶";

    // iPhone-sicheres Laden
    const img = await loadImageFromFile(f);

    // kleiner skalieren (damit es am iPhone nicht h√§ngt)
    const maxW = 700;
    const scale = Math.min(1, maxW / img.width);
    const w = Math.round(img.width * scale);
    const h = Math.round(img.height * scale);

    canvas.width = w; canvas.height = h;
    ctx.drawImage(img, 0, 0, w, h);
    canvas.style.display = "block";

    // Canvas -> Mat
    const imageData = ctx.getImageData(0,0,w,h);
    const srcRGBA = cv.matFromImageData(imageData);

    const bgr = new cv.Mat();
    cv.cvtColor(srcRGBA, bgr, cv.COLOR_RGBA2BGR);

    const hsv = new cv.Mat();
    cv.cvtColor(bgr, hsv, cv.COLOR_BGR2HSV);

    // Gr√ºn (etwas breiter)
    const green = new cv.Mat();
    cv.inRange(hsv, new cv.Scalar(30, 40, 40, 0), new cv.Scalar(110, 255, 255, 255), green);

    // Rot (wrap, etwas breiter)
    const red1 = new cv.Mat(), red2 = new cv.Mat(), red = new cv.Mat();
    cv.inRange(hsv, new cv.Scalar(0, 40, 40, 0),   new cv.Scalar(15, 255, 255, 255), red1);
    cv.inRange(hsv, new cv.Scalar(165, 40, 40, 0), new cv.Scalar(179, 255, 255, 255), red2);
    cv.bitwise_or(red1, red2, red);

    const greenClean = morphClean(green);
    const redClean   = morphClean(red);

    const r = countSquares(redClean);
    const g = countSquares(greenClean);

    out.textContent = `Resultat:\nüî¥ Rot: ${r}\nüü¢ Gr√ºn: ${g}`;

    // cleanup
    srcRGBA.delete(); bgr.delete(); hsv.delete();
    green.delete(); red1.delete(); red2.delete(); red.delete();
    greenClean.delete(); redClean.delete();

  } catch (e) {
    out.textContent = "Fehler:\n" + (e && e.message ? e.message : String(e));
  }
}

function waitForReady(){
  const tick = () => {
    if (window.cv && cv.Mat && cv.inRange) {
      statusEl.textContent = "OpenCV bereit ‚úÖ";
      runBtn.disabled = false;
      runBtn.onclick = run;
      return;
    }
    setTimeout(tick, 50);
  };
  tick();
}
waitForReady();
</script>
</body>
</html>
