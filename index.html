<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K√§stchen-Z√§hler (OpenCV final)</title>
  <style>
    body{font-family:system-ui; padding:16px; max-width:760px; margin:auto;}
    button{padding:10px 14px; font-size:16px;}
    #out{white-space:pre-wrap; background:#f4f4f4; padding:12px; border-radius:10px;}
    canvas{max-width:100%; border-radius:10px; margin-top:10px; display:none;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .small{font-size:12px; opacity:.75;}
  </style>
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
  <h2>K√§stchen-Z√§hler</h2>

  <div class="row">
    <input id="photo" type="file" accept="image/*" capture="environment" />
    <button id="run" disabled>Auswerten</button>
  </div>

  <p class="small" id="status">OpenCV l√§dt‚Ä¶</p>
  <pre id="out">Foto w√§hlen ‚Üí Auswerten</pre>

  <img id="img" style="display:none" alt="input" />
  <canvas id="cv"></canvas>

<script>
const statusEl = document.getElementById("status");
const out = document.getElementById("out");
const runBtn = document.getElementById("run");
const fileInput = document.getElementById("photo");
const imgEl = document.getElementById("img");
const canvas = document.getElementById("cv");

function morphClean(bin /* 8U */) {
  const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
  const tmp = new cv.Mat();
  const outm = new cv.Mat();
  cv.morphologyEx(bin, tmp, cv.MORPH_OPEN, kernel, new cv.Point(-1,-1), 1);
  cv.morphologyEx(tmp, outm, cv.MORPH_CLOSE, kernel, new cv.Point(-1,-1), 2);
  tmp.delete(); kernel.delete();
  return outm;
}

function countSquares(mask /* 8U */) {
  const labels = new cv.Mat();
  const stats  = new cv.Mat();
  const cent   = new cv.Mat();

  const n = cv.connectedComponentsWithStats(mask, labels, stats, cent, 8, cv.CV_32S);

  let count = 0;
  for (let i = 1; i < n; i++) {
    const w = stats.intAt(i, cv.CC_STAT_WIDTH);
    const h = stats.intAt(i, cv.CC_STAT_HEIGHT);
    const area = stats.intAt(i, cv.CC_STAT_AREA);

    // robustere Filter (nicht zu eng, damit iPhone/PNG klappt)
    if (area < 120 || area > 25000) continue;

    const aspect = w / h;
    if (aspect < 0.65 || aspect > 1.55) continue;

    const fill = area / (w * h);
    if (fill < 0.30) continue;

    count++;
  }

  labels.delete(); stats.delete(); cent.delete();
  return count;
}

function loadFileToImg(file){
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    imgEl.onload = () => { URL.revokeObjectURL(url); resolve(); };
    imgEl.onerror = () => { URL.revokeObjectURL(url); reject(new Error("Bild konnte nicht geladen werden.")); };
    imgEl.src = url;
  });
}

async function run(){
  try {
    const f = fileInput.files[0];
    if (!f) { out.textContent = "Bitte zuerst ein Foto ausw√§hlen."; return; }

    out.textContent = "Analysiere‚Ä¶";

    // iPhone-sicher laden
    await loadFileToImg(f);

    // OpenCV liest direkt aus <img>
    let src = cv.imread(imgEl); // RGBA
    // kleiner skalieren, damit Safari nicht h√§ngen bleibt
    const maxW = 700;
    if (src.cols > maxW) {
      const scale = maxW / src.cols;
      const dsize = new cv.Size(Math.round(src.cols * scale), Math.round(src.rows * scale));
      const resized = new cv.Mat();
      cv.resize(src, resized, dsize, 0, 0, cv.INTER_AREA);
      src.delete();
      src = resized;
    }

    // F√ºr Anzeige (optional)
    canvas.style.display = "block";
    cv.imshow(canvas, src);

    const bgr = new cv.Mat();
    cv.cvtColor(src, bgr, cv.COLOR_RGBA2BGR);

    const hsv = new cv.Mat();
    cv.cvtColor(bgr, hsv, cv.COLOR_BGR2HSV);

    // HSV: H 0..179, S/V 0..255
    // Gr√ºn (toleranter)
    const green = new cv.Mat();
    cv.inRange(hsv, new cv.Scalar(30, 40, 40, 0), new cv.Scalar(110, 255, 255, 255), green);

    // Rot (wrap, toleranter)
    const red1 = new cv.Mat(), red2 = new cv.Mat(), red = new cv.Mat();
    cv.inRange(hsv, new cv.Scalar(0, 40, 40, 0),   new cv.Scalar(15, 255, 255, 255), red1);
    cv.inRange(hsv, new cv.Scalar(165, 40, 40, 0), new cv.Scalar(179, 255, 255, 255), red2);
    cv.bitwise_or(red1, red2, red);

    const greenClean = morphClean(green);
    const redClean   = morphClean(red);

    const r = countSquares(redClean);
    const g = countSquares(greenClean);

    out.textContent = `Resultat:\nüî¥ Rot: ${r}\nüü¢ Gr√ºn: ${g}`;

    // cleanup
    src.delete(); bgr.delete(); hsv.delete();
    green.delete(); red1.delete(); red2.delete(); red.delete();
    greenClean.delete(); redClean.delete();

  } catch (e) {
    out.textContent = "Fehler:\n" + (e && e.message ? e.message : String(e));
  }
}

// WICHTIG: korrekt auf OpenCV warten
window.cv = window.cv || {};
cv.onRuntimeInitialized = () => {
  statusEl.textContent = "OpenCV bereit ‚úÖ";
  runBtn.disabled = false;
  runBtn.onclick = run;
};
</script>
</body>
</html>
