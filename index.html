<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>K√§stchen-Z√§hler (OpenCV)</title>
  <style>
    body{font-family:system-ui; padding:16px; max-width:760px; margin:auto;}
    button{padding:10px 14px; font-size:16px;}
    #out{white-space:pre-wrap; background:#f4f4f4; padding:12px; border-radius:10px;}
    canvas{max-width:100%; border-radius:10px; margin-top:10px; display:none;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .small{font-size:12px; opacity:.75;}
  </style>

  <!-- OpenCV.js (WebAssembly) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
  <h2>K√§stchen-Z√§hler (Foto ‚Üí Rot/Gr√ºn z√§hlen)</h2>

  <div class="row">
    <input id="photo" type="file" accept="image/*" capture="environment" />
    <button id="run" disabled>Auswerten</button>
  </div>

  <p class="small" id="status">OpenCV l√§dt‚Ä¶ (bitte kurz warten)</p>
  <pre id="out">Foto w√§hlen ‚Üí Auswerten</pre>
  <canvas id="cv"></canvas>

<script>
const out = document.getElementById("out");
const statusEl = document.getElementById("status");
const runBtn = document.getElementById("run");
const fileInput = document.getElementById("photo");
const canvas = document.getElementById("cv");
const ctx = canvas.getContext("2d", { willReadFrequently: true });

function waitForOpenCV() {
  return new Promise((resolve) => {
    const tick = () => {
      if (window.cv && cv.Mat) return resolve();
      setTimeout(tick, 50);
    };
    tick();
  });
}

function countSquaresFromMask(mask /* cv.Mat 8U */) {
  // connectedComponentsWithStats erwartet 8U (0/255)
  const labels = new cv.Mat();
  const stats  = new cv.Mat();
  const cent   = new cv.Mat();
  const n = cv.connectedComponentsWithStats(mask, labels, stats, cent, 8, cv.CV_32S);

  let count = 0;
  for (let i = 1; i < n; i++) { // 0 = background
    const x = stats.intAt(i, cv.CC_STAT_LEFT);
    const y = stats.intAt(i, cv.CC_STAT_TOP);
    const w = stats.intAt(i, cv.CC_STAT_WIDTH);
    const h = stats.intAt(i, cv.CC_STAT_HEIGHT);
    const area = stats.intAt(i, cv.CC_STAT_AREA);

    // Filter wie im Python-Ansatz (robust gegen Text/Timer)
    if (area < 250 || area > 5000) continue;

    const aspect = w / h;
    const tol = 0.35;
    if (aspect < (1 - tol) || aspect > (1 + tol)) continue;

    // F√ºllgrad (Text ist ‚Äúd√ºnn‚Äù)
    const fill = area / (w * h);
    if (fill < 0.35) continue;

    count++;
  }

  labels.delete(); stats.delete(); cent.delete();
  return count;
}

function morphClean(bin /* 8U */) {
  const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
  const tmp = new cv.Mat();
  const out = new cv.Mat();
  cv.morphologyEx(bin, tmp, cv.MORPH_OPEN, kernel, new cv.Point(-1,-1), 1);
  cv.morphologyEx(tmp, out, cv.MORPH_CLOSE, kernel, new cv.Point(-1,-1), 2);
  tmp.delete(); kernel.delete();
  return out;
}

async function run() {
  const f = fileInput.files[0];
  if (!f) { out.textContent = "Bitte zuerst ein Foto ausw√§hlen."; return; }

  out.textContent = "Analysiere‚Ä¶";

  const img = new Image();
  img.src = URL.createObjectURL(f);
  await img.decode();

  // Downscale f√ºr Performance, aber nicht zu klein
  const maxW = 900;
  const scale = Math.min(1, maxW / img.width);
  const w = Math.round(img.width * scale);
  const h = Math.round(img.height * scale);

  canvas.width = w; canvas.height = h;
  ctx.drawImage(img, 0, 0, w, h);
  canvas.style.display = "block";

  // Canvas -> OpenCV Mat
  const imageData = ctx.getImageData(0,0,w,h);
  const src = cv.matFromImageData(imageData);     // RGBA
  const bgr = new cv.Mat();
  cv.cvtColor(src, bgr, cv.COLOR_RGBA2BGR);

  const hsv = new cv.Mat();
  cv.cvtColor(bgr, hsv, cv.COLOR_BGR2HSV);

  // OpenCV HSV: H 0..179, S/V 0..255
  // Gr√ºn:
  const green = new cv.Mat();
  cv.inRange(hsv, new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [35, 80, 70, 0]),
                 new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [95, 255, 255, 0]), green);

  // Rot (wrap): [0..10] U [170..179]
  const red1 = new cv.Mat(), red2 = new cv.Mat(), red = new cv.Mat();
  cv.inRange(hsv, new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 80, 70, 0]),
                 new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [10, 255, 255, 0]), red1);
  cv.inRange(hsv, new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [170, 80, 70, 0]),
                 new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [179, 255, 255, 0]), red2);
  cv.bitwise_or(red1, red2, red);

  // Morphologie
  const greenClean = morphClean(green);
  const redClean   = morphClean(red);

  // Z√§hlen
  const redCount = countSquaresFromMask(redClean);
  const greenCount = countSquaresFromMask(greenClean);

  out.textContent = `Resultat:\nüî¥ Rot: ${redCount}\nüü¢ Gr√ºn: ${greenCount}`;

  // cleanup
  src.delete(); bgr.delete(); hsv.delete();
  green.delete(); red1.delete(); red2.delete(); red.delete();
  greenClean.delete(); redClean.delete();
}

(async () => {
  await waitForOpenCV();
  statusEl.textContent = "OpenCV bereit ‚úÖ";
  runBtn.disabled = false;
  runBtn.onclick = run;
})();
</script>
</body>
</html>
